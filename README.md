# 설명
디자인패턴을 정리합니다. 

참고한 책
- 개발자가 반드시 정복해야 할 객체지향과 디자인 패턴

# 전략(Strategy) 패턴
![strategy-pattern](/images/strategy-pattern.svg)

개념
- 콘텍스트에서 알고리즘을 별도로 분리하는 설계 방법이 전략 패턴이다. 

장점
- 새로운 알고리즘 추가될 때, 콘텍스트에는 코드 변경이 없다. 
- 확장에는 열려있고, 변경에는 닫혀있는 코드를 만들 수 있다. 

등장인물
- 콘텍스트(Context): Calculator
- 전략(Strategy): DiscountStrategy
- 전략 콘크리트 클래스(Strategy concrete class): FirstGuestDiscountStrategy, NonFreshItemDiscountStrategy

# 템플릿 메서드(Template Method) 패턴
![template-method-pattern](/images/template-method.svg)

개념
- 실행 과정은 같은데 각 단계 중 일부의 구현이 다른 경우에 사용할 수 있다.

등장 인물
- 실행 과정을 구현한 상위 클래스
- 실행 과정의 일부를 구현한 하위 클래스

# 상태(State) 패턴
VendingMachine 예시
- `동전을 넣는다`, `제품을 선택한다` 라는 동작이 있을 때, 이 동작들은 조건에 따라서 실행 내용과 결과가 달라지게 된다. 
   - 예: 동전을 넣었을 때 동전이 없었다면 
      1. 금액을 증가하고
      2. 상태를 '제품 선택 가능'으로 변경한다
- 이러한 코드는 패턴을 적용하지 않을때는 if/else를 이용해서 구현될 수 있다.

![state-pattern](/images/state.svg)

개념
- 기능이 상태에 따라 다르게 동작해야 할 때 사용할 수 있는 패턴.
- 상태를 별도 타입으로 분리하고, 상태별로 알맞은 하위 타입을 구현한다. 

등장 인물
- 콘텍스트: VendingMachine
- 상태: State
- 상태 콘크리트 클래스: NoCoinState, SelectableCointState, SoldoutState

장점
- 새로운 상태가 추가되더라도 콘텍스트 코드가 받는 영향은 최소화된다.
- 상태에 따른 동작을 구현한 코드가 상태별로 가지기 때문에 상태별 동작을 수정하기가 쉽다.

## 상태 변경 주체?
콘크리트 클래스에서 동작이 일어났을 때, 상태가 변경될 수 있다. 이러한 상태 변경은 콘텍스트, 콘크리트 클래스에 책임을 줄 수 있다. 

콘텍스트에 책임
- 상태가 작을 때는 효과적이다. 
- 상태가 많아지면 콘텍스트 클래스의 코드가 복잡해지기 때문에 상태 변경의 유연함이 떨어지게 된다. 

콘크리트 클래스에 책임
- 위에 그림처럼 콘텍스트 객체를 상태에 넘겨줘야한다. 
- 콘크리트 클래스에서는 전달 받은 콘텍스트 객체를 이용해서 상태 변경을 한다. 
- 콘텍스트에 영향을 주지 않으면서 상태를 변경할 수 있다. 
- 상태 변경 로직이 분산되기 때문에 상태가 많아지면 규칙을 파악하는게 어려워진다. 
   ![state-pattern](/images/stete2.svg)

